%\documentclass{pbml}
\documentclass[nofonts]{pbml} % use default fonts
%\documentclass[color]{pbml} % for color images and hypertext links

\usepackage{graphicx}
\usepackage{multicol}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{euler}
\usepackage{latexsym}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{wrapfig}
\usepackage{colortbl}
\usepackage{xcolor}
\usepackage{hyperref}
\usetikzlibrary{fit,positioning}

\hypersetup{
    colorlinks=false,
    pdfborder={0 0 0},
}

\newcommand{\ensuretext}[1]{#1}
\newcommand{\mycomment}[3]{\ensuretext{\textcolor{#3}{[#1 #2]}}}
\newcommand{\ammarker}{\ensuretext{\textcolor{blue}{\ensuremath{^{\textsc{A}}_{\textsc{M}}}}}}
\newcommand{\am}[1]{\mycomment{\ammarker}{#1}{blue}}
\newcommand{\cjmarker}{\ensuretext{\textcolor{red}{\ensuremath{^{\textsc{C}}_{\textsc{D}}}}}}
\newcommand{\cjd}[1]{\mycomment{\cjmarker}{#1}{red}}
\newcommand{\ignore}[1]{}
\newcolumntype{C}{>{\centering\arraybackslash}p{0.6ex}}

\begin{document}
\title{Tree Transduction Tools for cdec}

\institute{label1}{Carnegie Mellon University}
\institute{label2}{University of Oxford}

\author{
  firstname=Austin,
  surname=Matthews,
  institute=label1,
}
\author{
  firstname=Paul,
  surname=Baltescu,
  institute=label2,
}
\author{
  firstname=Phil,
  surname=Blunsom,
  institute=label2,
}
\author{
  firstname=Alon,
  surname=Lavie,
  institute=label1,
}
\author{
  firstname=Chris,
  surname=Dyer,
  institute=label1,
  corresponding=yes,
  email={cdyer@cs.cmu.edu},
  address={Language Technologies Institute\\Carnegie Mellon University\\Pittsburgh, PA 15213, United States}
}

\PBMLmaketitle

\begin{abstract}
We describe a collection of open source tools for learning
tree-to-string and tree-to-tree transducers and the extensions to the
cdec decoder that enable translation with these. Our modular,
easy-to-extned tools extract rules from trees or forests aligned to
strings and trees subject to different structural constraints. A fast,
multithreaded implementation of the Cohn and Blunsom (2009) model for
extracting compact tree-to-string rules is also included. The
implementation of the tree composition algorithm used by cdec is
described, and translation quality and decoding time results are
presented. Our results add to the body of evidence suggesting that
tree transduers are a compelling option for translation, particularly
when decoding speed and translation model size are important.
\end{abstract}

%\section{Introduction}

%\section*{Acknowledgements}
%This research is supported by \ldots

\section{Bayesian Synchronous Tree to String Grammar Induction}

In this section, we present an open source implementation of the synchronous tree-to-string grammar induction algorithm proposed by \citet{Cohn2009} \footnote{Our code is publicly available here: \url{https://github.com/pauldb89/worm}}. This algorithm relies on a Bayesian model which incorporates a prior preference for learning small, generalizable STSG rules. The model is designed to jointly learn translation rules and word alignments. This is important for capturing long distance reordering phenomena, which might otherwise be ignored if the rules are inferred using distance penalized alignments (e.g. as in the heuristic proposed by \citet{Galley2004}).

The model represents the tree-to-string grammar as a set of distributions $\{G_c\}$ over the productions of each non-terminal $c$. Each distribution $G_c$ is assumed to be generated by a Dirichlet Process with a concentration parameter $\alpha_c$ and a base distribution $P_0(\cdot | c)$, i.e. $G_c \sim DP(\alpha_c, P_0(\cdot | c))$. The concentration parameter $\alpha_c$ controls the model's tendency towards reusing rules or creating new ones according to the base distribution and has a direct influence on the size of the resulting grammar. The base distribution is defined to assign probabilities to an infinite set of rules. The probabilities decrease exponentially as the sizes of the rules increase, biasing the model towards learning smaller rules.

Instead of representing the distributions $G_c$ explicitly, we integrate over all the possible values of $G_c$. We obtain the following formula for estimating the probability of a rule $r$ with root $c$, given a fixed set of derivations $\textbf{r}$ for the training corpus:
\begin{equation}
p(r | \textbf{r}, c; \alpha_c, P_0) = \frac{n_{r} + \alpha_c P_0(r\ |\ c)}{n_{c} + \alpha_c},
\label{eq:sampling}
\end{equation}
where $n_{r}$ is the number of times $r$ occurs in $\textbf{r}$ and $n_{c}$ is the number of rules with root $c$ in $\textbf{r}$.

\citet{Cohn2009} train their model using Gibbs sampling. To simplify the implementation, an alignment variable is defined for every internal node in the parsed corpus. An alignment variable specifies the interval of target words which are spanned by a source node. Alternatively, a node may not be aligned to any target words or may span a discontiguous group of words, in which case it is annotated with an empty interval. Non-empty alignment variables mark the substitution sites for the rules in a derivation of a parse tree. Overall, they are used to specify a set of sampled derivations $\textbf{r}$ for the entire training data. Alignment spans are constrained to subsume the spans of their descendants and must be contained within the spans of their ancestors. In addition to this, sibling spans belonging to the frontier of the same rule must not overlap.

We implement Gibbs sampling with the help of two operators: \texttt{expand} and \texttt{swap}. The \texttt{expand} operator works by resampling a randomly selected alignment variable $a$, while keeping all the other alignment variables fixed. The set of possible outcomes consists of the empty interval and all the intervals assignable to $a$ such that the previous conditions continue to hold. Each outcome is scored proportionally to the new rules it creates,  using \autoref{eq:sampling}, conditioned on all the rules in the training data that remain unaffected by the sampling operation. The \texttt{swap} operator randomly selects two frontier nodes labelled with non-terminals belonging to the same STSG rule and chooses to either swap their alignment variables or to leave them unchanged. The outcomes are weighted similarly to the previous case. The goal of the \texttt{swap} operator is to improve the sampler's ability to mix, especially in the context of improving word reordering, by providing a way to execute several low probability \texttt{expand} steps at once.

Our implementation of the grammar induction algorithm is written in \texttt{C++}. Compiling the code results in several binaries, including \texttt{sampler}, which implements our Gibbs sampler. The grammar induction tool expects the following as input:
\begin{itemize}
\item A file containing the parse trees for the source side of the parallel corpus, in the Penn Treebank format.
\item A file containing the target side of the parallel corpus.
\item A file containing the word alignments for the training data. The word alignments are needed in the heuristic \citep{Galley2004} used to initialize the first set of derivations.
\item Two files containing the translation tables $p(s | t)$ and $p(t | s)$. These probabilities are used in the base distribution to weight the rules according to the source and target words they contain.
\end{itemize}
The remaining input arguments (hyperparameters, rule restrictions, etc.) are initialized with sensible default values. Running the binary with the \texttt{-{}-help} option will produce the complete list of arguments and a brief explanation for each. The tool produces several files as output, including one containing the set of rules together with their probabilities, computed based on the last set of sampled derivations. The documentation released with our code shows how to prepare the training data, run the tool and convert the output in the \texttt{cdec} format.
/github

Our tool leverages the benefits of a multithreaded environment to speed up grammar induction. At every sampler iteration, each training sentence is dynamically allocated to one of the available threads. In our implementation, we use a hash-based implementation of a Chinese Restaurant Process (CRP) \citep{Teh2010} to efficiently compute the rule probabilities given by \autoref{eq:sampling}. The data structure is updated whenever one of the \texttt{expand} or \texttt{swap} operators is applied. To lock this data structure with every update would completely cancel the effect of parallelization, as all the basic operations performed by the sampler are dependent on the CRP. Instead, we distribute a copy of the CRP on every thread and synchronize the data structures at the end of each iteration. Although the CRPs diverge during an iteration through the training data, no negative effects are observed when inferring STSGs in multithreaded mode.

\section{Hypergraph-based Grammar Extraction}
In order to alleviate these problems, we introduce an alternative methodology for rule extraction.
Instead of extracting rules from a pair of aligned \emph{trees}, we extract rules from a pair of
aligned \emph{hypergraphs}.

Note that any tree can easily be transformed into an equivalent hypergraph. To do this, simply replace
each terminal and non-terminal with a labeled node. Then, instead of connecting each node to its children
with one or more independent edges, create a hyperedge with its head at the parent node and a tail at each
of the child nodes. An example of such a hypergraph is shown in Figure \ref{simplehgfig}.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.25]{simplehg.png}
\caption{A pair of aligned trees, turned into hypergraphs. Non-terminal symbols are annotated with their half-open spans. \texttt{NP}$_{0,3}$ represents an \texttt{NP} over the span $[0,3)$.}
\label{simplehgfig}
\end{figure}

The next step of the rule extraction process is to find pairs of aligned nodes in the hypergraphs.
We will call a source node $S$ and a target node $T$ \emph{node-aligned} if the following conditions hold.
First, if $S$ and $T$ must either both be non-terminals or both be terminals.
Aligning a terminal to a non-terminal or vice-versa is disallowed.
Second, there must be at least one alignment link from a terminal dominated by $S$ to a terminal dominated by $T$.
Third, there must be no alignment links from terminals dominated by $S$ to terminals outside of $T$ or vice-versa.

We define a ``rule'' to be pair of hyperedges whose heads are node-aligned as per the above definition,
and whose non-terminal children are node-aligned in a one-to-one manner.
For example, in the sample tree, we see that the source node \texttt{PP}$_{4,6}$ is
node-aligned to the target node \texttt{PP}$_{5,7}$. Furthermore, their children are also node-aligned
one-to-one: \texttt{TO}$_{4,5}$ to \texttt{PREP}$_{5,6}$ and \texttt{NN}$_{5,6}$ to \texttt{NP}$_{5,7}$.
Thus this pair of edges will give rise to the rule \texttt{[PP::PP]} $\rightarrow$ \texttt{[TO,1] [NN,2] ||| [PREP,1] [NP,2]}.
Note that since there are no edges headed by terminals, so will not extract any rules with terminal heads.

The above formulation allows the extraction of minimal rules that do not skip any internal structure, but does not yet
include any mechanism for extracting \emph{composed} rules, which may skip levels of internal structure.
To capture such rules, we first pre-process each input hypergraph, recursively adding hyperedges from non-overlapping sets
of descendent nodes. For example, one hyperedge we add to the source side of the sample hypergraph pair is
\texttt{VP}$_{3,6}$ $\rightarrow$ \texttt{walked TO}$_{4,5}$ NN$_{5,6}$. Independently, on the target side we add an edge
\texttt{VP}$_{3,7}$ $\rightarrow$ \texttt{a march\'{e} PREP}$_{5,6}$ NP$_{5,7}$.

Now when we extract rules, we will find these two edges to be corresponding -- their heads are node-aligned, and their non-terminal
tails are also node-aligned one-to-one. Thus these two edges will combine to give the rule
\texttt{[VP::VP]} $\rightarrow$ \texttt{walked [TO,1] [NN,2] ||| a march\'{e} [PREP,1] [NP,2]}, a composed rule not extractable
by the bald algorithm.

While using composed edges allows us to extract all permissible rules from a pair of aligned trees, to be consistent with previous work,
we introduce one more type of hypergraph augmentation.
\citet{hanneman2011general} allow for adjacent sibling non-terminal nodes to be merged into one \emph{virtual node}, which may then be node-aligned to opposite nodes,
be they ``real'' or virtual. To enable this, we explicitly add virtual nodes to our hypergraph and connect them to their children with a hyperedge.
Furthermore, for every hyperedge that contained all of the sibling nodes
as non-terminal tails, we add a duplicate hyperedge that uses the new virtual node instead. For example, in figure \ref{virtualnodefig}, we have added a new non-terminal node
labeled \texttt{VB3s+VBN}$_{3,5}$ to the hypergraph. This node represents the fusion of the \texttt{VB3s}$_{3,4}$ and \texttt{VBN}$_{4,5}$ nodes.
We then add a hyperedge headed by the new \texttt{VB3s+VBN}$_{3,5}$ with tails to both \texttt{VB3s}$_{3,4}$ and \texttt{VBN}$_{4,5}$.
Furthermore, we make a copy of the edge \texttt{VP}$_{3,7}$ $\rightarrow$ \texttt{VB3s}$_{3,4}$ \texttt{VBN}$_{4,5}$ \texttt{PP}$_{5,7}$, and replace the
\texttt{VB3s}$_{3,4}$ and \texttt{VBN}$_{4,5}$ tail nodes with a single tail, \texttt{VB3s+VBN}$_{3,5}$, to form the new edge
\texttt{VP}$_{3,7}$ $\rightarrow$ \texttt{VB3s+VBN}$_{3,5}$ \texttt{PP}$_{5,7}$. The addition of this new hyperedge allows the extraction of the rules
\texttt{[VBD::VB3s+VBN]} $\rightarrow$ \texttt{walked ||| a march\'{e}} and
\texttt{[VP::VP]} $\rightarrow$ \texttt{[VBD,1] [PP,2]  ||| [VB3s+VBN,1] [PP,2]}, both of which were unextractable without the virtual node.

With the addition of virtual nodes, our work is directly comperable to \citet{hanneman2011general}, while being more modular, extensible and provably correct.
One particularly interesting extension our hypergraph formulation allows is the use of parse \emph{forests} rather than $1$-best trees.
\am{To be continued...}




\begin{figure}[ht!]
\centering
\includegraphics[scale=0.25]{virtualnode.png}
\caption{An example virtual node and its corresponding virtual edges.}
\label{virtualnodefig}
\end{figure}

\section*{Acknowledgements}
This research is supported by \ldots

\bibliography{mtm2014}

\correspondingaddress
\end{document}
